<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Async broadcast channel"><meta name="keywords" content="rust, rustlang, rust-lang, async_broadcast"><title>async_broadcast - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../async_broadcast/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../async_broadcast/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate async_broadcast</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.5.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">async_broadcast</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/async_broadcast/lib.rs.html#1-1875">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Async broadcast channel</p>
<p>An async multi-producer multi-consumer broadcast channel, where each consumer gets a clone of every
message sent on the channel. For obvious reasons, the channel can only be used to broadcast types
that implement <a href="https://doc.rust-lang.org/1.66.0/core/clone/trait.Clone.html" title="Clone"><code>Clone</code></a>.</p>
<p>A channel has the <a href="struct.Sender.html" title="Sender"><code>Sender</code></a> and <a href="struct.Receiver.html" title="Receiver"><code>Receiver</code></a> side. Both sides are cloneable and can be shared
among multiple threads.</p>
<p>When all <code>Sender</code>s or all <code>Receiver</code>s are dropped, the channel becomes closed. When a channel is
closed, no more messages can be sent, but remaining messages can still be received.</p>
<p>The channel can also be closed manually by calling <a href="struct.Sender.html#method.close" title="Sender::close()"><code>Sender::close()</code></a> or <a href="struct.Receiver.html#method.close" title="Receiver::close()"><code>Receiver::close()</code></a>.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_broadcast::{broadcast, TryRecvError};
<span class="kw">use </span>futures_lite::{future::block_on, stream::StreamExt};

block_on(<span class="kw">async move </span>{
    <span class="kw">let </span>(s1, <span class="kw-2">mut </span>r1) = broadcast(<span class="number">2</span>);
    <span class="kw">let </span>s2 = s1.clone();
    <span class="kw">let </span><span class="kw-2">mut </span>r2 = r1.clone();

    <span class="comment">// Send 2 messages from two different senders.
    </span>s1.broadcast(<span class="number">7</span>).<span class="kw">await</span>.unwrap();
    s2.broadcast(<span class="number">8</span>).<span class="kw">await</span>.unwrap();

    <span class="comment">// Channel is now at capacity so sending more messages will result in an error.
    </span><span class="macro">assert!</span>(s2.try_broadcast(<span class="number">9</span>).unwrap_err().is_full());
    <span class="macro">assert!</span>(s1.try_broadcast(<span class="number">10</span>).unwrap_err().is_full());

    <span class="comment">// We can use `recv` method of the `Stream` implementation to receive messages.
    </span><span class="macro">assert_eq!</span>(r1.next().<span class="kw">await</span>.unwrap(), <span class="number">7</span>);
    <span class="macro">assert_eq!</span>(r1.recv().<span class="kw">await</span>.unwrap(), <span class="number">8</span>);
    <span class="macro">assert_eq!</span>(r2.next().<span class="kw">await</span>.unwrap(), <span class="number">7</span>);
    <span class="macro">assert_eq!</span>(r2.recv().<span class="kw">await</span>.unwrap(), <span class="number">8</span>);

    <span class="comment">// All receiver got all messages so channel is now empty.
    </span><span class="macro">assert_eq!</span>(r1.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Empty));
    <span class="macro">assert_eq!</span>(r2.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Empty));

    <span class="comment">// Drop both senders, which closes the channel.
    </span>drop(s1);
    drop(s2);

    <span class="macro">assert_eq!</span>(r1.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Closed));
    <span class="macro">assert_eq!</span>(r2.try_recv(), <span class="prelude-val">Err</span>(TryRecvError::Closed));
})</code></pre></div>
<h3 id="difference-with-async-channel"><a href="#difference-with-async-channel">Difference with <code>async-channel</code></a></h3>
<p>This crate is similar to <a href="https://crates.io/crates/async-channel"><code>async-channel</code></a> in that they both provide an MPMC channel but the
main difference being that in <code>async-channel</code>, each message sent on the channel is only received
by one of the receivers. <code>async-broadcast</code> on the other hand, delivers each message to every
receiver (IOW broadcast) by cloning it for each receiver.</p>
<h3 id="difference-with-other-broadcast-crates"><a href="#difference-with-other-broadcast-crates">Difference with other broadcast crates</a></h3>
<ul>
<li>
<p><a href="https://crates.io/crates/broadcaster"><code>broadcaster</code></a>: The main difference would be that <code>broadcaster</code> doesn’t have a sender and
receiver split and both sides use clones of the same BroadcastChannel instance. The messages
are sent are sent to all channel clones. While this can work for many cases, the lack of
sender and receiver split, means that often times, you’ll find yourself having to drain the
channel on the sending side yourself.</p>
</li>
<li>
<p><a href="https://crates.io/crates/postage"><code>postage</code></a>: this crate provides a <a href="https://docs.rs/postage/0.4.1/postage/broadcast/fn.channel.html">broadcast API</a> similar to <code>async_broadcast</code>. However,
it:</p>
<ul>
<li>(at the time of this writing) duplicates <a href="https://crates.io/crates/futures">futures</a> API, which isn’t ideal.</li>
<li>Does not support overflow mode nor has the concept of inactive receivers, so a slow or
inactive receiver blocking the whole channel is not a solvable problem.</li>
<li>Provides all kinds of channels, which is generally good but if you just need a broadcast
channel, <code>async_broadcast</code> is probably a better choice.</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/1.6.0/tokio/sync"><code>tokio::sync</code></a>: Tokio’s <code>sync</code> module provides a <a href="https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html">broadcast channel</a> API. The differences
here are:</p>
<ul>
<li>While this implementation does provide <a href="https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html#lagging">overflow mode</a>, it is the default behavior and not
opt-in.</li>
<li>There is no equivalent of inactive receivers.</li>
<li>While it’s possible to build tokio with only the <code>sync</code> module, it comes with other APIs that
you may not need.</li>
</ul>
</li>
</ul>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InactiveReceiver.html" title="async_broadcast::InactiveReceiver struct">InactiveReceiver</a></div><div class="item-right docblock-short">An inactive  receiver.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Receiver.html" title="async_broadcast::Receiver struct">Receiver</a></div><div class="item-right docblock-short">The receiving side of a channel.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Recv.html" title="async_broadcast::Recv struct">Recv</a></div><div class="item-right docblock-short">A future returned by <a href="struct.Receiver.html#method.recv" title="Receiver::recv()"><code>Receiver::recv()</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Send.html" title="async_broadcast::Send struct">Send</a></div><div class="item-right docblock-short">A future returned by <a href="struct.Sender.html#method.broadcast" title="Sender::broadcast()"><code>Sender::broadcast()</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SendError.html" title="async_broadcast::SendError struct">SendError</a></div><div class="item-right docblock-short">An error returned from <a href="struct.Sender.html#method.broadcast" title="Sender::broadcast()"><code>Sender::broadcast()</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Sender.html" title="async_broadcast::Sender struct">Sender</a></div><div class="item-right docblock-short">The sending side of the broadcast channel.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RecvError.html" title="async_broadcast::RecvError enum">RecvError</a></div><div class="item-right docblock-short">An error returned from <a href="struct.Receiver.html#method.recv" title="Receiver::recv()"><code>Receiver::recv()</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TryRecvError.html" title="async_broadcast::TryRecvError enum">TryRecvError</a></div><div class="item-right docblock-short">An error returned from <a href="struct.Receiver.html#method.try_recv" title="Receiver::try_recv()"><code>Receiver::try_recv()</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TrySendError.html" title="async_broadcast::TrySendError enum">TrySendError</a></div><div class="item-right docblock-short">An error returned from <a href="struct.Sender.html#method.try_broadcast" title="Sender::try_broadcast()"><code>Sender::try_broadcast()</code></a>.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.broadcast.html" title="async_broadcast::broadcast fn">broadcast</a></div><div class="item-right docblock-short">Create a new broadcast channel.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="async_broadcast" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>