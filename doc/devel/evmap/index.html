<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A lock-free, eventually consistent, concurrent multi-value map."><meta name="keywords" content="rust, rustlang, rust-lang, evmap"><title>evmap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../evmap/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../evmap/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate evmap</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 10.0.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">evmap</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/evmap/lib.rs.html#1-475">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A lock-free, eventually consistent, concurrent multi-value map.</p>
<p>This map implementation allows reads and writes to execute entirely in parallel, with no
implicit synchronization overhead. Reads never take locks on their critical path, and neither
do writes assuming there is a single writer (multi-writer is possible using a <code>Mutex</code>), which
significantly improves performance under contention.</p>
<p>The trade-off exposed by this module is one of eventual consistency: writes are not visible to
readers except following explicit synchronization. Specifically, readers only see the
operations that preceeded the last call to <code>WriteHandle::refresh</code> by a writer. This lets
writers decide how stale they are willing to let reads get. They can refresh the map after
every write to emulate a regular concurrent <code>HashMap</code>, or they can refresh only occasionally to
reduce the synchronization overhead at the cost of stale reads.</p>
<p>For read-heavy workloads, the scheme used by this module is particularly useful. Writers can
afford to refresh after every write, which provides up-to-date reads, and readers remain fast
as they do not need to ever take locks.</p>
<p>The map is multi-value, meaning that every key maps to a <em>collection</em> of values. This
introduces some memory cost by adding a layer of indirection through a <code>Vec</code> for each value,
but enables more advanced use. This choice was made as it would not be possible to emulate such
functionality on top of the semantics of this map (think about it – what would the operational
log contain?).</p>
<p>To faciliate more advanced use-cases, each of the two maps also carry some customizeable
meta-information. The writers may update this at will, and when a refresh happens, the current
meta will also be made visible to readers. This could be useful, for example, to indicate what
time the refresh happened.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Single-reader, single-writer</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// new will use the default HashMap hasher, and a meta of ()
// note that we get separate read and write handles
// the read handle can be cloned to have more readers
</span><span class="kw">let </span>(book_reviews_r, <span class="kw-2">mut </span>book_reviews_w) = evmap::new();

<span class="comment">// review some books.
</span>book_reviews_w.insert(<span class="string">&quot;Adventures of Huckleberry Finn&quot;</span>,    <span class="string">&quot;My favorite book.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>,               <span class="string">&quot;Masterpiece.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;Pride and Prejudice&quot;</span>,               <span class="string">&quot;Very enjoyable.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;The Adventures of Sherlock Holmes&quot;</span>, <span class="string">&quot;Eye lyked it alot.&quot;</span>);

<span class="comment">// at this point, reads from book_reviews_r will not see any of the reviews!
</span><span class="macro">assert_eq!</span>(book_reviews_r.len(), <span class="number">0</span>);
<span class="comment">// we need to refresh first to make the writes visible
</span>book_reviews_w.refresh();
<span class="macro">assert_eq!</span>(book_reviews_r.len(), <span class="number">4</span>);
<span class="comment">// reads will now return Some() because the map has been initialized
</span><span class="macro">assert_eq!</span>(book_reviews_r.get(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>).map(|rs| rs.len()), <span class="prelude-val">Some</span>(<span class="number">1</span>));

<span class="comment">// remember, this is a multi-value map, so we can have many reviews
</span>book_reviews_w.insert(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>,               <span class="string">&quot;Eh, the title seemed weird.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;Pride and Prejudice&quot;</span>,               <span class="string">&quot;Too many words.&quot;</span>);

<span class="comment">// but again, new writes are not yet visible
</span><span class="macro">assert_eq!</span>(book_reviews_r.get(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>).map(|rs| rs.len()), <span class="prelude-val">Some</span>(<span class="number">1</span>));

<span class="comment">// we need to refresh first
</span>book_reviews_w.refresh();
<span class="macro">assert_eq!</span>(book_reviews_r.get(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>).map(|rs| rs.len()), <span class="prelude-val">Some</span>(<span class="number">2</span>));

<span class="comment">// oops, this review has a lot of spelling mistakes, let&#39;s delete it.
// empty deletes *all* reviews (though in this case, just one)
</span>book_reviews_w.empty(<span class="string">&quot;The Adventures of Sherlock Holmes&quot;</span>);
<span class="comment">// but again, it&#39;s not visible to readers until we refresh
</span><span class="macro">assert_eq!</span>(book_reviews_r.get(<span class="string">&quot;The Adventures of Sherlock Holmes&quot;</span>).map(|rs| rs.len()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
book_reviews_w.refresh();
<span class="macro">assert_eq!</span>(book_reviews_r.get(<span class="string">&quot;The Adventures of Sherlock Holmes&quot;</span>).map(|rs| rs.len()), <span class="prelude-val">None</span>);

<span class="comment">// look up the values associated with some keys.
</span><span class="kw">let </span>to_find = [<span class="string">&quot;Pride and Prejudice&quot;</span>, <span class="string">&quot;Alice&#39;s Adventure in Wonderland&quot;</span>];
<span class="kw">for </span>book <span class="kw">in </span><span class="kw-2">&amp;</span>to_find {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(reviews) = book_reviews_r.get(book) {
        <span class="kw">for </span>review <span class="kw">in </span><span class="kw-2">&amp;*</span>reviews {
            <span class="macro">println!</span>(<span class="string">&quot;{}: {}&quot;</span>, book, review);
        }
    } <span class="kw">else </span>{
        <span class="macro">println!</span>(<span class="string">&quot;{} is unreviewed.&quot;</span>, book);
    }
}

<span class="comment">// iterate over everything.
</span><span class="kw">for </span>(book, reviews) <span class="kw">in </span><span class="kw-2">&amp;</span>book_reviews_r.read().unwrap() {
    <span class="kw">for </span>review <span class="kw">in </span>reviews {
        <span class="macro">println!</span>(<span class="string">&quot;{}: \&quot;{}\&quot;&quot;</span>, book, review);
    }
}</code></pre></div>
<p>Reads from multiple threads are possible by cloning the <code>ReadHandle</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::thread;
<span class="kw">let </span>(book_reviews_r, <span class="kw-2">mut </span>book_reviews_w) = evmap::new();

<span class="comment">// start some readers
</span><span class="kw">let </span>readers: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..<span class="number">4</span>).map(|<span class="kw">_</span>| {
    <span class="kw">let </span>r = book_reviews_r.clone();
    thread::spawn(<span class="kw">move </span>|| {
        <span class="kw">loop </span>{
            <span class="kw">let </span>l = r.len();
            <span class="kw">if </span>l == <span class="number">0 </span>{
                thread::yield_now();
            } <span class="kw">else </span>{
                <span class="comment">// the reader will either see all the reviews,
                // or none of them, since refresh() is atomic.
                </span><span class="macro">assert_eq!</span>(l, <span class="number">4</span>);
                <span class="kw">break</span>;
            }
        }
    })
}).collect();

<span class="comment">// do some writes
</span>book_reviews_w.insert(<span class="string">&quot;Adventures of Huckleberry Finn&quot;</span>,    <span class="string">&quot;My favorite book.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;Grimms&#39; Fairy Tales&quot;</span>,               <span class="string">&quot;Masterpiece.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;Pride and Prejudice&quot;</span>,               <span class="string">&quot;Very enjoyable.&quot;</span>);
book_reviews_w.insert(<span class="string">&quot;The Adventures of Sherlock Holmes&quot;</span>, <span class="string">&quot;Eye lyked it alot.&quot;</span>);
<span class="comment">// expose the writes
</span>book_reviews_w.refresh();

<span class="comment">// you can read through the write handle
</span><span class="macro">assert_eq!</span>(book_reviews_w.len(), <span class="number">4</span>);

<span class="comment">// the original read handle still works too
</span><span class="macro">assert_eq!</span>(book_reviews_r.len(), <span class="number">4</span>);

<span class="comment">// all the threads should eventually see .len() == 4
</span><span class="kw">for </span>r <span class="kw">in </span>readers.into_iter() {
    <span class="macro">assert!</span>(r.join().is_ok());
}</code></pre></div>
<p>If multiple writers are needed, the <code>WriteHandle</code> must be protected by a <code>Mutex</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::thread;
<span class="kw">use </span>std::sync::{Arc, Mutex};
<span class="kw">let </span>(book_reviews_r, <span class="kw-2">mut </span>book_reviews_w) = evmap::new();

<span class="comment">// start some writers.
// since evmap does not support concurrent writes, we need
// to protect the write handle by a mutex.
</span><span class="kw">let </span>w = Arc::new(Mutex::new(book_reviews_w));
<span class="kw">let </span>writers: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..<span class="number">4</span>).map(|i| {
    <span class="kw">let </span>w = w.clone();
    thread::spawn(<span class="kw">move </span>|| {
        <span class="kw">let </span><span class="kw-2">mut </span>w = w.lock().unwrap();
        w.insert(i, <span class="bool-val">true</span>);
        w.refresh();
    })
}).collect();

<span class="comment">// eventually we should see all the writes
</span><span class="kw">while </span>book_reviews_r.len() &lt; <span class="number">4 </span>{ thread::yield_now(); };

<span class="comment">// all the threads should eventually finish writing
</span><span class="kw">for </span>w <span class="kw">in </span>writers.into_iter() {
    <span class="macro">assert!</span>(w.join().is_ok());
}</code></pre></div>
<p><code>ReadHandle</code> is not <code>Sync</code> as it is not safe to share a single instance
amongst threads. A fresh <code>ReadHandle</code> needs to be created for each thread
either by cloning a <code>ReadHandle</code> or from a <code>ReadHandleFactory</code>.</p>
<p>The reason for this is that each <code>ReadHandle</code> assumes that only one
thread operates on it at a time. For details, see the implementation
comments on <code>ReadHandle</code>.</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>evmap::ReadHandle;

 <span class="kw">fn </span>is_sync&lt;T: Sync&gt;() {
   <span class="comment">// dummy function just used for its parameterized type bound
 </span>}

 <span class="comment">// the line below will not compile as ReadHandle does not implement Sync

 </span>is_sync::&lt;ReadHandle&lt;u64, u64&gt;&gt;()</code></pre></div>
<p><code>ReadHandle</code> <strong>is</strong> <code>Send</code> though, since in order to send a <code>ReadHandle</code>,
there must be no references to it, so no thread is operating on it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>evmap::ReadHandle;

 <span class="kw">fn </span>is_send&lt;T: Send&gt;() {
   <span class="comment">// dummy function just used for its parameterized type bound
 </span>}

 is_send::&lt;ReadHandle&lt;u64, u64&gt;&gt;()</code></pre></div>
<p>For further explanation of <code>Sync</code> and <code>Send</code> <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">here</a></p>
<h2 id="implementation"><a href="#implementation">Implementation</a></h2>
<p>Under the hood, the map is implemented using two regular <code>HashMap</code>s, an operational log,
epoch counting, and some pointer magic. There is a single pointer through which all readers
go. It points to a <code>HashMap</code>, which the readers access in order to read data. Every time a read
has accessed the pointer, they increment a local epoch counter, and they update it again when
they have finished the read (see #3 for more information). When a write occurs, the writer
updates the other <code>HashMap</code> (for which there are no readers), and also stores a copy of the
change in a log (hence the need for <code>Clone</code> on the keys and values). When
<code>WriteHandle::refresh</code> is called, the writer, atomically swaps the reader pointer to point to
the other map. It then waits for the epochs of all current readers to change, and then replays
the operational log to bring the stale map up to date.</p>
<p>Since the implementation uses regular <code>HashMap</code>s under the hood, table resizing is fully
supported. It does, however, also mean that the memory usage of this implementation is
approximately twice of that of a regular <code>HashMap</code>, and more if writes rarely refresh after
writing.</p>
<h2 id="value-storage"><a href="#value-storage">Value storage</a></h2>
<p>The values for each key in the map are stored in <a href="struct.Values.html" title="Values"><code>Values</code></a>. Conceptually, each <code>Values</code> is a
<em>bag</em> or <em>multiset</em>; it can store multiple copies of the same value. <code>evmap</code> applies some
cleverness in an attempt to reduce unnecessary allocations and keep the cost of operations on
even large value-bags small. For small bags, <code>Values</code> uses the <code>smallvec</code> crate. This avoids
allocation entirely for single-element bags, and uses a <code>Vec</code> if the bag is relatively small.
For large bags, <code>Values</code> uses the <code>hashbag</code> crate, which enables <code>evmap</code> to efficiently look up
and remove specific elements in the value bag. For bags larger than one element, but smaller
than the threshold for moving to <code>hashbag</code>, we use <code>smallvec</code> to avoid unnecessary hashing.
Operations such as <code>Fit</code> and <code>Replace</code> will automatically switch back to the inline storage if
possible. This is ideal for maps that mostly use one element per key, as it can improvate
memory locality with less indirection.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.ShallowCopy"><code>pub use crate::shallow_copy::<a class="trait" href="shallow_copy/trait.ShallowCopy.html" title="trait evmap::shallow_copy::ShallowCopy">ShallowCopy</a>;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="shallow_copy/index.html" title="evmap::shallow_copy mod">shallow_copy</a></div><div class="item-right docblock-short">Types that can be cheaply aliased.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MapReadRef.html" title="evmap::MapReadRef struct">MapReadRef</a></div><div class="item-right docblock-short">A live reference into the read half of an evmap.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Options.html" title="evmap::Options struct">Options</a></div><div class="item-right docblock-short">Options for how to initialize the map.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Predicate.html" title="evmap::Predicate struct">Predicate</a></div><div class="item-right docblock-short">Unary predicate used to retain elements.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ReadGuard.html" title="evmap::ReadGuard struct">ReadGuard</a></div><div class="item-right docblock-short">A guard wrapping a live reference into an evmap.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ReadGuardIter.html" title="evmap::ReadGuardIter struct">ReadGuardIter</a></div><div class="item-right docblock-short">An <a href="https://doc.rust-lang.org/1.66.0/core/iter/traits/iterator/trait.Iterator.html" title="Iterator"><code>Iterator</code></a> over keys and values in the evmap.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ReadHandle.html" title="evmap::ReadHandle struct">ReadHandle</a></div><div class="item-right docblock-short">A handle that may be used to read from the eventually consistent map.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ReadHandleFactory.html" title="evmap::ReadHandleFactory struct">ReadHandleFactory</a></div><div class="item-right docblock-short">A type that is both <code>Sync</code> and <code>Send</code> and lets you produce new <a href="struct.ReadHandle.html" title="ReadHandle"><code>ReadHandle</code></a> instances.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Values.html" title="evmap::Values struct">Values</a></div><div class="item-right docblock-short">A bag of values for a given key in the evmap.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WriteHandle.html" title="evmap::WriteHandle struct">WriteHandle</a></div><div class="item-right docblock-short">A handle that may be used to modify the eventually consistent map.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Operation.html" title="evmap::Operation enum">Operation</a></div><div class="item-right docblock-short">A pending map operation.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.new.html" title="evmap::new fn">new</a></div><div class="item-right docblock-short">Create an empty eventually consistent map.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.with_hasher.html" title="evmap::with_hasher fn">with_hasher</a></div><div class="item-right docblock-short">Create an empty eventually consistent map with meta information and custom hasher.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.with_meta.html" title="evmap::with_meta fn">with_meta</a></div><div class="item-right docblock-short">Create an empty eventually consistent map with meta information.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="evmap" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>