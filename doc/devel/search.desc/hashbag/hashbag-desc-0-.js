searchState.loadedDescShard("hashbag", 0, "An unordered multiset/bag implementation backed by <code>HashMap</code>.\nAn draining iterator over the distinct items of a <code>HashBag</code> …\nA view into a single entry in the bag, which may either be …\nA hash bag implemented as a <code>HashMap</code> where the value is …\nAn owning iterator over the distinct items of a <code>HashBag</code> …\nAn iterator over the items of a <code>HashBag</code>.\nAn iterator over the distinct items of a <code>HashBag</code> and their …\nProvides in-place mutable access to an occupied entry …\nReturns the number of distinct values the bag can hold …\nClears the bag, removing all values.\nReturns the number of instances of <code>value</code> in the bag.\nReturns an iterator over all the elements that are in <code>self</code> …\nClears the bag, returning all elements in an iterator.\nGets a given value’s corresponding entry in the bag for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value in the bag, if any, that …\nReturns a reference to the bag’s <code>BuildHasher</code>.\nAdds a value to the bag.\nAdds multiple occurrences of a value to the bag.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the bag contains no elements.\nAn iterator visiting all elements in arbitrary order.\nReturns the number of elements in the bag.\nCreates an empty <code>HashBag</code>.\nReturns an iterator over all of the elements that are in …\nEnsures there is at least one instance of the value before …\nEnsures there is at least <code>quantity</code> instances of the value …\nReturns an iterator over all of the elements that are in …\nRemoves a value from the bag.\nRemoves multiple of a value from the bag. If <code>quantity</code> is …\nAdds a value to the bag, replacing all existing …\nReserves capacity for at least <code>additional</code> more distinct …\nRetains only the values specified by the predicate.\nAn iterator visiting all distinct elements in arbitrary …\nReturns the number of elements in the bag.\nShrinks the capacity of the ba as much as possible. It …\nReturns an iterator over all the elements that are in <code>self</code> …\nRemoves and returns all occurrences of the value, if any, …\nRemoves a value that is equal to the given one, and …\nReturns a reference to the entry’s value.\nCreates an empty <code>HashBag</code> with the specified capacity.\nCreates an empty <code>HashBag</code> with the specified capacity, using\nCreates a new empty hash bag which will use the given …")