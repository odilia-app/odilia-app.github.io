searchState.loadedDescShard("odilia_tower", 0, "Integrations for the Odilia screen reader and the <code>tower</code> …\nA trait <code>AsyncTryFrom</code>, its associated layer …\nAllow postfix notation for building services from existing …\nA generic state provider service. This clones the state …\nSynchronous version of <code>crate::async_try</code>. Create …\nA service built specifically to run <code>.unwrap()</code> on computed …\nA version of <code>tower::util::future::AndThenFuture</code> that is …\nAn async version of <code>TryFrom</code> with an associated future.\nAn async version of <code>TryInto</code> with an associated future.\nA ZST representing a <code>AsyncTryInto</code> as a <code>tower::Layer</code>.\nA service which applies an <code>AsyncTryInto</code> transformation to …\nThe possible conversion error.\nThe possible conversion error.\nNamed future (for use with other <code>tower</code> components. Will be …\nNamed future (for use with other <code>tower</code> components. Will be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrap the inner service with an <code>AsyncTryInto</code> function …\nCreate a new <code>AsyncTryIntoLayer</code> from generic types.\nAttempt to asynchronously convert a value from <code>T</code> to <code>Self</code>.\nAttempt to asynchronously convert a value from <code>T</code> to <code>Self</code>.\nUse postfix notation on your <code>tower::Service</code>s to produce …\nMap a new input type into your service’s input using a …\nMap a new input type into your service’s input using a …\nInject a clonable state into each invocation of the inner …\nA <code>tower::Layer</code> which stores state <code>S</code>.\nA service which clones state <code>Sta</code> into the <code>Service::call</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>StateLayer</code> with service of type <code>S</code>.\nA ZST describing a layer which runs the corresponding …\nA service which maps from a new input into the inner …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>TryIntoService</code> from an inner <code>tower::Service</code>.\nCreate a new <code>TryIntoLayer</code> from the generic types.\nA future which flattens a future’s nested results when …\nMap the <code>Ok</code> variant of <code>Service::call</code> into a new type. Where …\nMaps a response value of <code>Result&lt;T, E&gt;</code> to …\nMap a future result into return of …\nA future which unwraps the future’s <code>Future::Output</code> value …\nAdd postfix notation for <code>TryIntoCommandFut</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrap an inner service.\nWrap an inner service.\nMap’s a future into it’s corresponding …")