<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="BGT Lover">
<meta name=keywords content="prototype rust ">
<meta name=description content="As of afew days ago, we decided we played enough with the tools and components of the linux accessibility stack to be
able to say that we aren&rsquo;t so ignorant anymore, we know at least the basics about how it all fits together, how our
screenreaders read information from a linux gui app, how the gui toolkit and atspi work together to provide the required
context for such tools to operate.
Since I don&rsquo;t want to bore you with code snippets, git logs, conversations from who knows how much time ago and so on, I
will quickly give you a rundown of everything we learned during this long, laborious but nevertheless fun and
educational journey">
<link rel=license type=text/html href=https://www.gnu.org/licenses/agpl-3.0-standalone.html>
<link rel=license type=text/html href=https://creativecommons.org/licenses/by-sa/4.0/>
<link rel=stylesheet type=text/css href=/css/style.css encoding=UTF-8>
<link rel=stylesheet type=text/css href=/css/syntax.css encoding=UTF-8>
<title>Enough Prototypes, let's do this for real | Odilia Screen Reader</title>
</head>
<body>
<div id=container>
<nav class=global-nav>
<ul class=nav-list>
<li class=nav-item>
<a href=/ class=nav-link>
Home
</a>
</li>
<li class=nav-item>
<a href=/news/ class="nav-link active" aria-current=true>
News
</a>
</li>
<li class=nav-item>
<a href=/design/ class=nav-link>
Design
</a>
</li>
<li class=nav-item>
<a href=https://github.com/odilia-app class=nav-link>
Code
</a>
</li>
</ul>
</nav>
<main>
<article>
<header>
<h1>Enough Prototypes, let's do this for real</h1>
<small>
Published on <time datetime=2022-02-02>February 2, 2022</time>
by <a href=https://odilia.app/authors/bgt-lover/>BGT Lover</a>&#183; 5 minutes read
<br>
<nav aria-label="Post tags">
<a href=https://odilia.app/tags/prototype/>prototype</a> &#183; <a href=https://odilia.app/tags/rust/>rust</a></nav>
</small>
</header>
<p>As of afew days ago, we decided we played enough with the tools and components of the linux accessibility stack to be
able to say that we aren&rsquo;t so ignorant anymore, we know at least the basics about how it all fits together, how our
screenreaders read information from a linux gui app, how the gui toolkit and atspi work together to provide the required
context for such tools to operate.</p>
<p>Since I don&rsquo;t want to bore you with code snippets, git logs, conversations from who knows how much time ago and so on, I
will quickly give you a rundown of everything we learned during this long, laborious but nevertheless fun and
educational journey</p>
<h2 id=what-we-learned>what we learned</h2>
<ol>
<li>Atspi is not so impossible to work with after all. If you worked with windows a11y before, even if only through the
nvda python console, things shouldn&rsquo;t be terribly alien to you. All accessible applications offer a tree of
components called accessible objects which have mostly readonly properties such as text, role, relations and so on,
events through which they can report internal changes, and methods through which they can be modifyed to some extent.
If you also manage to wrap your head around dbus, it&rsquo;s not that hard honestly.</li>
<li>Async Rust is pretty hard, async Rust that communicates with evdev is harder. We&rsquo;re using an async architecture based
on Tokio, in the hopes that this will make better use of the CPU and provide higher performance and reliability. A
downside to this is that code can be significantly harder to write, and a little harder to understand sometimes.
Working with the kernel API&rsquo;s was always hard, introduce logic to bridge that model to the async model Rust uses is
very hard, our architecture for that is not really sound.</li>
<li>Glib is hard to understand, even harder to master, hardest of all to bind. I understand what the people behind it
wanted to do, an object oriented library that offers a concrete hierarchy of tipes in a formal specification,
bindings to different languages being generated by special generators. It&rsquo;s written in c for maximum performance and
all that, at the same time offering high-level oop like abstractions over OS utilities, making a devs life much
easier than if they were writing programs in raw c with the OS API&rsquo;s. However, what resulted is, in my opinion, a
monolithic framework that&rsquo;s non-intuitive to work with for the most part, binding generators that don&rsquo;t produce
idiomatic code if they are able to generate all of the interface in the first place, looking at you,
<a href=https://github.com/gtk-rs/gir>gir</a>, weird datastructures like garray which are very hard to reason with in other
languages, again, trying to do that in Rust was a pane, etc. Among some other miner reasons, that&rsquo;s why we chose to
not bind libatspi, but instead communicate with the atspi registrid directly through dbus.</li>
<li>In atspi land, everything is a node in a tree, even some desktop decorations that may or may not be visible to the
sighted, having to sometimes filter out the junk. This will be important later, especially when we&rsquo;re dealing with
object navigation, allowing the user to freely move through the accessibility tree. We must find some heuristics that
would allow us to just skip the decorative parts, mostly by trial and error. Alternatively, we can contact the
developers of desktops we see this happening in, offering them directions on how to remove the junk.</li>
<li>Working with the kernel directly is frowned upon for security reasons, however evdev brings us advantages and
features atspi isn&rsquo;t made to give us, so we&rsquo;re willing to accept the risk. Note: in addon space, we would have to be
very careful about what we will allow to register as a keybinding, how are we going to allow addons to register
keybindings in the first place, since evdev gives us privilidged access to every input device the kernel recognises,
that means even the power button could be used as a key, I don&rsquo;t think users would be very happy if that were the
case. So, a malicious addon could easily lock up your keyboard, touchscreen, trackpad and whatever else if we aren&rsquo;t
careful with the design, perhaps only allow keybindings that are present in a pattern we either hardcode or allow the
user to extend in a config file, anything else would be rejected.</li>
<li>DBUS code can be wordy and verbose at times, error messages more criptic than true cifertext, but it beats working
with libatspi, a nightmare to bind with in Rust. FFI is not hard to do generally, but glib requires too much effort,
the binding generators for Rust just aren&rsquo;t up to the job yet.</li>
<li>Modularity is good, but too much modularity is bad. We were working on many crates separately, the only common
denominator between them being that they are inside the Odilia github org. That means cargo isn&rsquo;t able to reliably
track versions for us, plus it generally got a bit chaotic towards the end. Furthermore, some of those crates
shouldn&rsquo;t have been separated at all imho, that&rsquo;s why we are working now on unifying those crates, we&rsquo;ll primarily
use cargo workspaces.</li>
</ol>
<h1 id=final-thoughts>final thoughts</h1>
<p>this has been a very interesting journey indeed, I personally learned more things from this prototype than most other
projects I made. However, as all playing has to eventually come to an end, we think it should end now. The prototype
played its role in all this, it&rsquo;s time to do it for real. For everyone who supported us so far, either by giving
feedback, spreading the news around, even by being in the testing group and helping us test whatever comes in the stream
of conciousness that the testing branch still is, we thank you, one and all. To some degree, you influenced the growth
of the odilia screenreader, you are a part of how things are now.</p>
<p>With that out of the way, expect more news shortly, maybe. Let&rsquo;s hope this is a good sign for Odilia. As always, let&rsquo;s
build a linux screenreader together, one step at a time!</p>
</article>
</main>
<footer id=footer>
Copyright &copy; 2022
<a href=https://github.com/orgs/odilia-app/people target=_blank>the Odilia developers</a>
(Code is <a rel=license href=https://www.gnu.org/licenses/agpl-3.0-standalone.html target=blank>AGPL 3</a>,
content is <a rel=license href=https://creativecommons.org/licenses/by-sa/4.0/ target=blank>CC-BY-SA 4.0</a>)
</footer>
</div>
</body>
</html>